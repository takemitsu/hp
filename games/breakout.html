<!DOCTYPE html>
<html lang="ja" data-bs-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ãƒ–ãƒ­ãƒƒã‚¯å´©ã—</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'JetBrains Mono', monospace;
    }

    button {
      touch-action: manipulation;
    }

    #gameCanvas {
      border: 3px solid var(--bs-primary);
      border-radius: 0.5rem;
      background: #000;
      display: block;
      margin: 0 auto;
      max-width: 100%;
      touch-action: none;
    }

    .stats-card {
      text-align: center;
      padding: 1rem;
    }

    .stats-number {
      font-size: 2rem;
      font-weight: bold;
    }

    .settings-panel {
      background-color: var(--bs-secondary-bg-subtle);
      border-radius: 0.375rem;
      padding: 20px;
      margin-bottom: 20px;
    }

    .control-btn {
      font-size: 2rem;
      font-weight: bold;
      height: 80px;
      touch-action: manipulation;
      user-select: none;
    }

    @media (max-width: 576px) {
      .stats-number {
        font-size: 1.5rem;
      }

      .control-btn {
        font-size: 1.5rem;
        height: 60px;
      }
    }
  </style>
</head>
<body>
<nav class="navbar bg-body-tertiary" id="header" aria-label="header">
  <div class="container-fluid justify-content-start">
    <a class="navbar-brand" href="/">takemitsu.net</a>
    <div class="nav-text">ãƒ–ãƒ­ãƒƒã‚¯å´©ã—</div>

    <ul class="navbar-nav flex-row ms-auto mb-2 mb-lg-0">
      <li class="nav-item mx-1"><a class="nav-link" href="#" onclick="changeTheme('dark')">dark</a></li>
      <li class="nav-item mx-1"><a class="nav-link" href="#" onclick="changeTheme('light')">light</a></li>
    </ul>
  </div>
</nav>

<div class="container mt-3">
  <div class="row justify-content-center">
    <div class="col-12 col-md-10 col-lg-8">

      <!-- è¨­å®šãƒ‘ãƒãƒ« -->
      <div class="settings-panel" id="settings-panel">
        <h5 class="mb-3">ã‚²ãƒ¼ãƒ èª¬æ˜</h5>

        <div class="alert alert-info">
          <strong>ãƒ–ãƒ­ãƒƒã‚¯å´©ã—</strong><br>
          æ˜”ãªãŒã‚‰ã®ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ–ãƒ­ãƒƒã‚¯å´©ã—ã‚²ãƒ¼ãƒ ã€‚<br>
          ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œã—ã¦ãƒœãƒ¼ãƒ«ã‚’è·³ã­è¿”ã—ã€å…¨ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç ´å£Šã—ã‚ˆã†ï¼
        </div>

        <div class="mb-3">
          <label class="form-label">ãƒœãƒ¼ãƒ«æŒã¡è¶Šã—ä¸Šé™</label>
          <div class="btn-group w-100" role="group">
            <input type="radio" class="btn-check" name="ballLimit" id="limit10" value="10" checked>
            <label class="btn btn-outline-primary" for="limit10" style="touch-action: manipulation;">10å€‹</label>
            <input type="radio" class="btn-check" name="ballLimit" id="limit20" value="20">
            <label class="btn btn-outline-primary" for="limit20" style="touch-action: manipulation;">20å€‹</label>
            <input type="radio" class="btn-check" name="ballLimit" id="limitMax" value="999">
            <label class="btn btn-outline-primary" for="limitMax" style="touch-action: manipulation;">ç„¡åˆ¶é™</label>
          </div>
          <small class="text-muted">æ¬¡ã®ã‚¦ã‚§ãƒ¼ãƒ–ã«æŒã¡è¶Šã›ã‚‹ãƒœãƒ¼ãƒ«ã®æœ€å¤§æ•°</small>
        </div>

        <div class="d-grid">
          <button class="btn btn-primary btn-lg" onclick="startGame()">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
        </div>
      </div>

      <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
      <div id="game-panel" style="display: none;">
        <div class="card mb-2">
          <div class="card-body">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <span>Wave <span id="current-wave">1</span></span>
              <span>Score: <span id="score">0</span></span>
            </div>

            <canvas id="gameCanvas" width="600" height="800"></canvas>

            <div class="row g-2 mt-3">
              <div class="col-6">
                <button class="btn btn-primary control-btn w-100" id="leftBtn">â† LEFT</button>
              </div>
              <div class="col-6">
                <button class="btn btn-primary control-btn w-100" id="rightBtn">RIGHT â†’</button>
              </div>
            </div>
          </div>
        </div>

        <!-- çµ±è¨ˆæƒ…å ± -->
        <div class="row g-2">
          <div class="col-4">
            <div class="card stats-card">
              <div class="stats-number text-info" id="ball-count">1</div>
              <small>ç¾åœ¨ãƒœãƒ¼ãƒ«</small>
            </div>
          </div>
          <div class="col-4">
            <div class="card stats-card">
              <div class="stats-number text-primary" id="ball-max">10</div>
              <small>æŒè¶Šä¸Šé™</small>
            </div>
          </div>
          <div class="col-4">
            <div class="card stats-card">
              <div class="stats-number text-success" id="blocks-left">0</div>
              <small>æ®‹ãƒ–ãƒ­ãƒƒã‚¯</small>
            </div>
          </div>
        </div>
      </div>

      <!-- çµæœç”»é¢ -->
      <div class="card" id="result-panel" style="display: none;">
        <div class="card-body text-center">
          <h3 class="mb-4">Game Over</h3>

          <div class="row g-3 mb-4">
            <div class="col-6">
              <div class="card stats-card">
                <div class="stats-number text-success" id="final-wave">0</div>
                <small>åˆ°é”Wave</small>
              </div>
            </div>
            <div class="col-6">
              <div class="card stats-card">
                <div class="stats-number text-primary" id="final-score">0</div>
                <small>ã‚¹ã‚³ã‚¢</small>
              </div>
            </div>
          </div>

          <div class="d-grid">
            <button class="btn btn-primary" onclick="showSettings()">ã‚‚ã†ä¸€åº¦</button>
          </div>
        </div>
      </div>

      <div class="alert alert-info mt-3" role="alert">
        <h5 class="alert-heading">éŠã³æ–¹</h5>
        <p class="mb-0">
          <strong>1.</strong> å·¦å³ãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ç”»é¢ã‚¿ãƒƒãƒï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼‰ã§ãƒ‘ãƒ‰ãƒ«ã‚’æ“ä½œ<br>
          <strong>2.</strong> ç”»é¢ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯/ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ãƒœãƒ¼ãƒ«ç™ºå°„<br>
          <strong>3.</strong> å…¨ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç ´å£Šã—ã¦ã‚¦ã‚§ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢
        </p>
      </div>

      <div class="alert alert-secondary mt-3" role="alert">
        <p class="mb-0 text-center">
          ğŸ’¡ ã‚²ãƒ¼ãƒ ã®ã‚¢ã‚¤ãƒ‡ã‚£ã‚¢å‹Ÿé›†ä¸­ï¼
        </p>
      </div>

    </div>
  </div>
</div>

<script src="../setTheme.mini.js"></script>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ã‚²ãƒ¼ãƒ çŠ¶æ…‹
let gameState = {
  isPlaying: false,
  wave: 0,
  score: 0,
  paddle: null,
  balls: [],
  blocks: [],
  keys: { left: false, right: false },
  isTransitioning: false,  // ã‚¦ã‚§ãƒ¼ãƒ–åˆ‡ã‚Šæ›¿ãˆä¸­ãƒ•ãƒ©ã‚°
  maxBallCarryover: 10,    // ãƒœãƒ¼ãƒ«æŒã¡è¶Šã—ä¸Šé™
  // å£Šã‚Œè¦ç´ ã®å¼·åº¦
  angleRandomness: 0,      // åå°„è§’ãƒ©ãƒ³ãƒ€ãƒ åº¦ (0-1)
  speedVariation: 0,       // é€Ÿåº¦å¤‰åŒ– (0-1)
  blockMovement: 0,        // ãƒ–ãƒ­ãƒƒã‚¯ç§»å‹•é€Ÿåº¦
  paddleShrink: 1,         // ãƒ‘ãƒ‰ãƒ«ã‚µã‚¤ã‚ºå€ç‡ (1-0.25)
  blockRespawn: false      // ãƒ–ãƒ­ãƒƒã‚¯å¢—æ®–
};

// ãƒ‘ãƒ‰ãƒ«
class Paddle {
  constructor() {
    this.baseWidth = 300;
    this.width = this.baseWidth;
    this.height = 15;
    this.x = canvas.width / 2 - this.width / 2;
    this.y = canvas.height - 30;
    this.speed = 8;
    this.prevX = this.x; // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®Xåº§æ¨™
    this.velocity = 0;   // ãƒ‘ãƒ‰ãƒ«ã®é€Ÿåº¦
  }

  update() {
    this.width = this.baseWidth * gameState.paddleShrink;

    // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½ç½®ã‚’è¨˜éŒ²
    this.prevX = this.x;

    if (gameState.keys.left && this.x > 0) {
      this.x -= this.speed;
    }
    if (gameState.keys.right && this.x < canvas.width - this.width) {
      this.x += this.speed;
    }

    // ãƒ‘ãƒ‰ãƒ«ã®é€Ÿåº¦ã‚’è¨ˆç®—
    this.velocity = this.x - this.prevX;
  }

  draw() {
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

// ãƒœãƒ¼ãƒ«
class Ball {
  constructor(x, y, dx, dy) {
    this.x = x || canvas.width / 2;
    this.y = y || canvas.height - 60;
    this.radius = 6;
    this.baseSpeed = 6;
    this.dx = dx || 0;
    this.dy = dy || 0;
    this.isLaunched = (dx !== undefined && dy !== undefined); // ç™ºå°„æ¸ˆã¿ãƒ•ãƒ©ã‚°
  }

  update() {
    // æœªç™ºå°„ã®å ´åˆã¯ãƒ‘ãƒ‰ãƒ«ã«è¿½å¾“
    if (!this.isLaunched) {
      const paddle = gameState.paddle;
      this.x = paddle.x + paddle.width / 2;
      this.y = paddle.y - this.radius;
      return false;
    }

    this.x += this.dx;
    this.y += this.dy;

    // å£åå°„
    if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
      this.dx = -this.dx;
      this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
    }
    if (this.y - this.radius < 0) {
      this.dy = -this.dy;
      this.y = this.radius;
    }

    // ãƒ‘ãƒ‰ãƒ«åå°„
    const paddle = gameState.paddle;
    if (this.y + this.radius >= paddle.y &&
        this.y - this.radius < paddle.y + paddle.height &&
        this.x >= paddle.x &&
        this.x <= paddle.x + paddle.width) {

      this.dy = -Math.abs(this.dy);
      this.y = paddle.y - this.radius;

      // åå°„è§’ã®è¨ˆç®—ï¼ˆãƒ‘ãƒ‰ãƒ«ã®ã©ã“ã«å½“ãŸã£ãŸã‹ï¼‰
      const hitPos = (this.x - paddle.x) / paddle.width; // 0-1
      const angle = (hitPos - 0.5) * Math.PI / 3; // -60åº¦ã€œ+60åº¦

      // å£Šã‚Œè¦ç´ ï¼šãƒ©ãƒ³ãƒ€ãƒ è§’åº¦è¿½åŠ 
      const randomAngle = (Math.random() - 0.5) * Math.PI * gameState.angleRandomness;
      const finalAngle = angle + randomAngle;

      const speed = this.baseSpeed;
      this.dx = speed * Math.sin(finalAngle);
      this.dy = -speed * Math.cos(finalAngle);

      // ãƒ‘ãƒ‰ãƒ«ã®å‹•ãã«ã‚ˆã‚‹æ‘©æ“¦åŠ¹æœï¼ˆè‹±èªã‚’ã‹ã‘ã‚‹ï¼‰
      const frictionFactor = 0.3; // æ‘©æ“¦ã®å¼·ã•ï¼ˆ0-1ï¼‰
      this.dx += paddle.velocity * frictionFactor;

      // æœ€ä½Yé€Ÿåº¦ã‚’ä¿è¨¼ï¼ˆæ°´å¹³ã«è¿‘ã™ãã‚‹è§’åº¦ã‚’é˜²ãï¼‰
      const minYSpeed = this.baseSpeed * 0.5;
      if (Math.abs(this.dy) < minYSpeed) {
        this.dy = this.dy < 0 ? -minYSpeed : minYSpeed;
      }

      // å£Šã‚Œè¦ç´ ï¼šé€Ÿåº¦å¤‰åŒ–
      if (gameState.speedVariation > 0) {
        const speedMult = 1 + (Math.random() - 0.5) * gameState.speedVariation;
        this.dx *= speedMult;
        this.dy *= speedMult;
      }
    }

    // ãƒ–ãƒ­ãƒƒã‚¯è¡çª
    for (let i = gameState.blocks.length - 1; i >= 0; i--) {
      const block = gameState.blocks[i];
      if (!block.destroyed && this.collidesWith(block)) {
        this.handleBlockCollision(block);

        // ãƒ–ãƒ­ãƒƒã‚¯ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
        const isDestroyed = block.hit();

        if (isDestroyed) {
          gameState.blocks.splice(i, 1);
          gameState.score += block.isSpecial ? 50 : (10 * block.maxHp);

          // ç‰¹æ®Šãƒ–ãƒ­ãƒƒã‚¯ï¼šãƒœãƒ¼ãƒ«å¢—æ®–
          if (block.isSpecial) {
            this.explode();
          }

          // ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Šæ™‚ã«ãƒ©ãƒ³ãƒ€ãƒ ã§ãƒœãƒ¼ãƒ«åŠ é€Ÿï¼ˆ30%ã®ç¢ºç‡ï¼‰
          if (Math.random() < 0.3) {
            const speedBoost = 1.2;
            this.dx *= speedBoost;
            this.dy *= speedBoost;
          }
        } else {
          // ã¾ã å£Šã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚³ã‚¢ã ã‘åŠ ç®—
          gameState.score += 5;
        }
      }
    }

    // ç”»é¢ä¸‹ã«è½ã¡ãŸ
    return this.y - this.radius > canvas.height;
  }

  collidesWith(block) {
    return this.x + this.radius > block.x &&
           this.x - this.radius < block.x + block.width &&
           this.y + this.radius > block.y &&
           this.y - this.radius < block.y + block.height;
  }

  handleBlockCollision(block) {
    // ã‚ˆã‚Šç²¾å¯†ãªåå°„åˆ¤å®š
    const prevX = this.x - this.dx;
    const prevY = this.y - this.dy;

    // ãƒœãƒ¼ãƒ«ã®å‰ã®ä½ç½®ã‹ã‚‰ã€ã©ã®é¢ã«å½“ãŸã£ãŸã‹ã‚’åˆ¤å®š
    const fromLeft = prevX < block.x;
    const fromRight = prevX > block.x + block.width;
    const fromTop = prevY < block.y;
    const fromBottom = prevY > block.y + block.height;

    // å·¦å³ã®é¢ã«å½“ãŸã£ãŸ
    if (fromLeft || fromRight) {
      this.dx = -this.dx;
      // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã«ã‚ã‚Šè¾¼ã‚“ã§ã„ãŸã‚‰æŠ¼ã—å‡ºã™
      if (fromLeft) {
        this.x = block.x - this.radius;
      } else {
        this.x = block.x + block.width + this.radius;
      }
    }

    // ä¸Šä¸‹ã®é¢ã«å½“ãŸã£ãŸ
    if (fromTop || fromBottom) {
      this.dy = -this.dy;
      // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã«ã‚ã‚Šè¾¼ã‚“ã§ã„ãŸã‚‰æŠ¼ã—å‡ºã™
      if (fromTop) {
        this.y = block.y - this.radius;
      } else {
        this.y = block.y + block.height + this.radius;
      }
    }

    // ã©ã®é¢ã‹ã‚‰ã‚‚æ¥ã¦ã„ãªã„å ´åˆï¼ˆè§’ã«å½“ãŸã£ãŸï¼‰ã¯ä¸¡æ–¹åè»¢
    if (!fromLeft && !fromRight && !fromTop && !fromBottom) {
      this.dx = -this.dx;
      this.dy = -this.dy;
    }
  }

  explode() {
    // ãƒœãƒ¼ãƒ«ã‚’20ã€œ30å€‹ã«å¢—æ®–
    const count = 20 + Math.floor(Math.random() * 11);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = this.baseSpeed;
      const dx = speed * Math.cos(angle);
      const dy = speed * Math.sin(angle);
      gameState.balls.push(new Ball(this.x, this.y, dx, dy));
    }
  }

  draw() {
    ctx.fillStyle = '#FFF';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ãƒ–ãƒ­ãƒƒã‚¯
class Block {
  constructor(x, y, isSpecial = false, hp = 1, isIndestructible = false) {
    this.x = x;
    this.y = y;
    this.width = 50;
    this.height = 20;
    this.isSpecial = isSpecial;
    this.isIndestructible = isIndestructible; // å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯
    this.hp = hp; // è€ä¹…åŠ›
    this.maxHp = hp; // æœ€å¤§HPï¼ˆè‰²ã®åˆ¤å®šç”¨ï¼‰
    this.destroyed = false;
    this.moveDir = Math.random() < 0.5 ? -1 : 1;
  }

  hit() {
    // å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãªã„
    if (this.isIndestructible) return false;

    // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
    this.hp--;
    return this.hp <= 0; // ç ´å£Šã•ã‚ŒãŸã‚‰true
  }

  update() {
    // å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ã¯ç§»å‹•ã—ãªã„
    if (this.isIndestructible) return;

    // å£Šã‚Œè¦ç´ ï¼šãƒ–ãƒ­ãƒƒã‚¯ç§»å‹•
    if (gameState.blockMovement > 0) {
      this.x += this.moveDir * gameState.blockMovement;

      // ç”»é¢ç«¯ã§åè»¢
      if (this.x < 0 || this.x + this.width > canvas.width) {
        this.moveDir *= -1;
        this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
      }
    }
  }

  draw() {
    if (this.isIndestructible) {
      // å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆç°è‰²ï¼‰
      ctx.fillStyle = '#555';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.strokeRect(this.x, this.y, this.width, this.height);
      ctx.lineWidth = 1;

      // Xãƒãƒ¼ã‚¯ã‚’æç”»
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x + 5, this.y + 5);
      ctx.lineTo(this.x + this.width - 5, this.y + this.height - 5);
      ctx.moveTo(this.x + this.width - 5, this.y + 5);
      ctx.lineTo(this.x + 5, this.y + this.height - 5);
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (this.isSpecial) {
      // è™¹è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
      const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
      gradient.addColorStop(0, '#FF0000');
      gradient.addColorStop(0.33, '#00FF00');
      gradient.addColorStop(0.66, '#0000FF');
      gradient.addColorStop(1, '#FF00FF');
      ctx.fillStyle = gradient;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.strokeStyle = '#000';
      ctx.strokeRect(this.x, this.y, this.width, this.height);
    } else {
      // HPã«å¿œã˜ã¦è‰²ã‚’å¤‰ãˆã‚‹
      if (this.maxHp === 1) {
        ctx.fillStyle = '#2196F3'; // é’ï¼ˆé€šå¸¸ï¼‰
      } else if (this.maxHp === 2) {
        ctx.fillStyle = this.hp === 2 ? '#FFA500' : '#FFD700'; // ã‚ªãƒ¬ãƒ³ã‚¸â†’é»„è‰²
      } else if (this.maxHp === 3) {
        if (this.hp === 3) ctx.fillStyle = '#FF4500'; // èµ¤
        else if (this.hp === 2) ctx.fillStyle = '#FF6347'; // è–„ã„èµ¤
        else ctx.fillStyle = '#FFB6C1'; // ãƒ”ãƒ³ã‚¯
      } else {
        // HP4ä»¥ä¸Šã¯ç´«ç³»
        const ratio = this.hp / this.maxHp;
        const brightness = Math.floor(100 + ratio * 100);
        ctx.fillStyle = `rgb(${brightness}, 0, ${brightness})`;
      }
      ctx.fillRect(this.x, this.y, this.width, this.height);
      ctx.strokeStyle = '#000';
      ctx.strokeRect(this.x, this.y, this.width, this.height);

      // HPè¡¨ç¤ºï¼ˆHP2ä»¥ä¸Šã®å ´åˆï¼‰
      if (this.maxHp > 1) {
        ctx.fillStyle = '#FFF';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.hp, this.x + this.width / 2, this.y + this.height / 2);
      }
    }
  }
}

// ãƒ–ãƒ­ãƒƒã‚¯é…ç½®ç”Ÿæˆ
function generateBlocks(wave) {
  const blocks = [];
  const maxRows = 16; // æœ€å¤§16è¡Œï¼ˆç”»é¢é«˜ã•2å€ï¼‰
  const rows = Math.min(maxRows, 3 + Math.floor(wave / 3));
  const cols = 10;
  const padding = 10;
  const offsetX = (canvas.width - (cols * 60)) / 2;
  const offsetY = 50;

  // é€šå¸¸ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®ï¼ˆHPã¯Waveã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      if (Math.random() < 0.7) { // 70%ã®ç¢ºç‡ã§é…ç½®
        const x = offsetX + col * 60 + padding;
        const y = offsetY + row * 30 + padding;

        // Waveæ•°ã«å¿œã˜ã¦è€ä¹…åŠ›ã®é«˜ã„ãƒ–ãƒ­ãƒƒã‚¯ãŒå‡ºç¾ï¼ˆæ®µéšçš„ã«ç¢ºç‡UPï¼‰
        let hp = 1;

        // HP2ã®ç¢ºç‡: Wave 5ã§20% â†’ Wave 10ã§40% â†’ Wave 20ã§80%
        if (wave >= 5) {
          const hp2Chance = Math.min(0.8, 0.2 + (wave - 5) * 0.04);
          if (Math.random() < hp2Chance) hp = 2;
        }

        // HP3ã®ç¢ºç‡: Wave 10ã§10% â†’ Wave 15ã§25% â†’ Wave 25ã§50%
        if (wave >= 10 && hp === 1) {
          const hp3Chance = Math.min(0.5, 0.1 + (wave - 10) * 0.03);
          if (Math.random() < hp3Chance) hp = 3;
        }

        // HP4ã®ç¢ºç‡: Wave 15ã§5% â†’ Wave 20ã§15% â†’ Wave 30ã§30%
        if (wave >= 15 && hp === 1) {
          const hp4Chance = Math.min(0.3, 0.05 + (wave - 15) * 0.02);
          if (Math.random() < hp4Chance) hp = 4;
        }

        blocks.push(new Block(x, y, false, hp));
      }
    }
  }

  // å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ï¼ˆWave 3ã‹ã‚‰ï¼‰
  // æ—¢å­˜ãƒ–ãƒ­ãƒƒã‚¯ã¨é‡ãªã‚‰ãªã„ä½ç½®ã«é…ç½®
  if (wave >= 3) {
    const indestructibleCount = Math.min(10, Math.floor((wave - 2) / 2));
    const occupiedPositions = new Set();

    // æ—¢å­˜ãƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®ã‚’è¨˜éŒ²
    blocks.forEach(block => {
      occupiedPositions.add(`${block.x},${block.y}`);
    });

    let attempts = 0;
    let placed = 0;
    while (placed < indestructibleCount && attempts < 100) {
      const x = offsetX + Math.floor(Math.random() * cols) * 60 + padding;
      const y = offsetY + Math.floor(Math.random() * rows) * 30 + padding;
      const posKey = `${x},${y}`;

      // é‡è¤‡ã—ã¦ã„ãªã‘ã‚Œã°é…ç½®
      if (!occupiedPositions.has(posKey)) {
        blocks.push(new Block(x, y, false, 1, true));
        occupiedPositions.add(posKey);
        placed++;
      }
      attempts++;
    }
  }

  // è™¹è‰²ãƒ–ãƒ­ãƒƒã‚¯æ•°ã‚’è¨ˆç®—: 1 + (waveé€²è¡Œåº¦ Ã— å‰²åˆ), æœ€å¤§5å€‹
  const specialCount = Math.min(5, 1 + Math.floor(wave / 5));

  // ãƒ©ãƒ³ãƒ€ãƒ ã«specialCountå€‹ã‚’è™¹è‰²ã«ã™ã‚‹ï¼ˆå£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ä»¥å¤–ã‹ã‚‰ï¼‰
  const destructibleBlocks = blocks.filter(b => !b.isIndestructible);
  if (destructibleBlocks.length > 0) {
    const actualSpecialCount = Math.min(specialCount, destructibleBlocks.length);
    const shuffled = [...destructibleBlocks].sort(() => Math.random() - 0.5);
    for (let i = 0; i < actualSpecialCount; i++) {
      shuffled[i].isSpecial = true;
    }
  }

  return blocks;
}

// ã‚¦ã‚§ãƒ¼ãƒ–é–‹å§‹
function startWave() {
  gameState.wave++;
  gameState.blocks = generateBlocks(gameState.wave);

  // Wave 1ã¯æŒã¡è¶Šã—ä¸Šé™æ•°ã®ãƒœãƒ¼ãƒ«ã§é–‹å§‹ã€ãã‚Œä»¥é™ã¯æŒã¡è¶Šã—
  if (gameState.wave === 1) {
    gameState.balls = [];
    for (let i = 0; i < gameState.maxBallCarryover; i++) {
      gameState.balls.push(new Ball());
    }
  } else {
    // æŒã¡è¶Šã—ä¸Šé™ã‚’é©ç”¨
    if (gameState.balls.length > gameState.maxBallCarryover) {
      gameState.balls = gameState.balls.slice(0, gameState.maxBallCarryover);
    }

    // æ—¢å­˜ã®ãƒœãƒ¼ãƒ«ã‚’å…¨ã¦æœªç™ºå°„çŠ¶æ…‹ã«
    for (const ball of gameState.balls) {
      ball.isLaunched = false;
      ball.dx = 0;
      ball.dy = 0;
    }
  }

  // å£Šã‚Œè¦ç´ ã®å¼·åº¦ã‚’æ®µéšçš„ã«ä¸Šã’ã‚‹ï¼ˆã‚‚ã£ã¨æ—©ãå¼·ãï¼‰
  const wave = gameState.wave;

  if (wave >= 2) gameState.angleRandomness = Math.min(0.5, (wave - 1) * 0.2);
  if (wave >= 3) gameState.speedVariation = Math.min(1.2, (wave - 2) * 0.3);
  if (wave >= 4) gameState.blockMovement = Math.min(3, (wave - 3) * 0.5);
  if (wave >= 5) gameState.paddleShrink = Math.max(0.3, 1 - (wave - 4) * 0.06);
  if (wave >= 6) gameState.angleRandomness = Math.min(1.5, (wave - 5) * 0.3 + 0.5);

  updateStats();
}

// çµ±è¨ˆæ›´æ–°
function updateStats() {
  document.getElementById('current-wave').textContent = gameState.wave;
  document.getElementById('score').textContent = gameState.score;
  document.getElementById('ball-count').textContent = gameState.balls.length;
  document.getElementById('ball-max').textContent = gameState.maxBallCarryover === 999 ? 'âˆ' : gameState.maxBallCarryover;

  // æ®‹ãƒ–ãƒ­ãƒƒã‚¯æ•°ã¯å£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’é™¤ã
  const destructibleBlocks = gameState.blocks.filter(b => !b.isIndestructible).length;
  document.getElementById('blocks-left').textContent = destructibleBlocks;
}

// ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
function gameLoop() {
  if (!gameState.isPlaying) return;

  // ã‚¯ãƒªã‚¢
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // æ›´æ–°
  gameState.paddle.update();

  for (const block of gameState.blocks) {
    block.update();
  }

  for (let i = gameState.balls.length - 1; i >= 0; i--) {
    const isDead = gameState.balls[i].update();
    if (isDead) {
      gameState.balls.splice(i, 1);
    }
  }

  // æç”»
  gameState.paddle.draw();

  for (const block of gameState.blocks) {
    block.draw();
  }

  for (const ball of gameState.balls) {
    ball.draw();
  }

  // çµ±è¨ˆæ›´æ–°
  updateStats();

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
  if (gameState.balls.length === 0) {
    endGame();
    return;
  }

  // ã‚¦ã‚§ãƒ¼ãƒ–ã‚¯ãƒªã‚¢åˆ¤å®šï¼ˆå£Šã‚Œãªã„ãƒ–ãƒ­ãƒƒã‚¯ä»¥å¤–ã‚’å…¨ã¦ç ´å£Šï¼‰
  const destructibleBlocks = gameState.blocks.filter(b => !b.isIndestructible);
  if (destructibleBlocks.length === 0 && gameState.balls.length > 0 && !gameState.isTransitioning) {
    gameState.isTransitioning = true;
    setTimeout(() => {
      gameState.isTransitioning = false;
      startWave();
    }, 1000);
  }

  requestAnimationFrame(gameLoop);
}

// ã‚²ãƒ¼ãƒ é–‹å§‹
function startGame() {
  const ballLimit = parseInt(document.querySelector('input[name="ballLimit"]:checked').value);

  gameState = {
    isPlaying: true,
    wave: 0,
    score: 0,
    paddle: new Paddle(),
    balls: [],
    blocks: [],
    keys: { left: false, right: false },
    isTransitioning: false,
    maxBallCarryover: ballLimit,
    angleRandomness: 0,
    speedVariation: 0,
    blockMovement: 0,
    paddleShrink: 1,
    blockRespawn: false
  };

  document.getElementById('settings-panel').style.display = 'none';
  document.getElementById('game-panel').style.display = 'block';
  document.getElementById('result-panel').style.display = 'none';

  startWave();
  gameLoop();
}

// ã‚²ãƒ¼ãƒ çµ‚äº†
function endGame() {
  gameState.isPlaying = false;

  document.getElementById('final-wave').textContent = gameState.wave;
  document.getElementById('final-score').textContent = gameState.score;

  document.getElementById('game-panel').style.display = 'none';
  document.getElementById('result-panel').style.display = 'block';
}

// è¨­å®šç”»é¢ã«æˆ»ã‚‹
function showSettings() {
  document.getElementById('settings-panel').style.display = 'block';
  document.getElementById('game-panel').style.display = 'none';
  document.getElementById('result-panel').style.display = 'none';
  gameState.isPlaying = false;
}

// æ“ä½œ
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

leftBtn.addEventListener('mousedown', () => gameState.keys.left = true);
leftBtn.addEventListener('mouseup', () => gameState.keys.left = false);
leftBtn.addEventListener('mouseleave', () => gameState.keys.left = false);
leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keys.left = true; });
leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.keys.left = false; });

rightBtn.addEventListener('mousedown', () => gameState.keys.right = true);
rightBtn.addEventListener('mouseup', () => gameState.keys.right = false);
rightBtn.addEventListener('mouseleave', () => gameState.keys.right = false);
rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keys.right = true; });
rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.keys.right = false; });

// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') gameState.keys.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') gameState.keys.right = true;
  if (e.key === ' ') {
    e.preventDefault(); // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ–
    launchBall();
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a') gameState.keys.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') gameState.keys.right = false;
});

// ãƒœãƒ¼ãƒ«ç™ºå°„
function launchBall() {
  if (!gameState.isPlaying) return;

  for (const ball of gameState.balls) {
    if (!ball.isLaunched) {
      ball.isLaunched = true;
      ball.dx = ball.baseSpeed * (Math.random() - 0.5) * 0.5; // å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ ã«
      // Yæ–¹å‘ã®ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚‚ãƒãƒ©ã¤ã‹ã›ã‚‹ï¼ˆ0.8ã€œ1.2å€ï¼‰
      const speedVariation = 0.8 + Math.random() * 0.4;
      ball.dy = -ball.baseSpeed * speedVariation;
    }
  }
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§ç™ºå°„
canvas.addEventListener('click', launchBall);
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  launchBall();
});

// ã‚¿ãƒƒãƒãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ‰ãƒ«ç§»å‹•
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!gameState.isPlaying || !gameState.paddle) return;

  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const touchX = (touch.clientX - rect.left) * scaleX;

  // ãƒ‘ãƒ‰ãƒ«ã®ä¸­å¿ƒãŒæŒ‡ã®ä½ç½®ã«ãªã‚‹ã‚ˆã†ã«è¨­å®š
  gameState.paddle.x = touchX - gameState.paddle.width / 2;

  // ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«ã‚¯ãƒ©ãƒ³ãƒ—
  gameState.paddle.x = Math.max(0, Math.min(canvas.width - gameState.paddle.width, gameState.paddle.x));
});
</script>
</body>
</html>
